<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>å®¶åº­ç¯®çƒè·‘é…·</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

body {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    touch-action: none;
}

#container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #1a237e;
}

#game {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
    display: block;
}

#ui {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
    pointer-events: none;
}

.ui-panel {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.9);
    border-radius: 20px;
    padding: 25px;
    max-width: 90%;
    margin: 0 auto;
    border: 2px solid rgba(255, 255, 255, 0.1);
}

h1, h2, h3 {
    color: #fff;
    text-align: center;
    margin-bottom: 20px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

h1 {
    font-size: clamp(24px, 6vw, 36px);
    color: #FFD700;
}

h2 {
    font-size: clamp(20px, 5vw, 28px);
}

h3 {
    font-size: clamp(18px, 4vw, 24px);
}

p {
    color: #fff;
    text-align: center;
    margin: 10px 0;
    font-size: clamp(14px, 3.5vw, 16px);
    line-height: 1.5;
}

button {
    display: block;
    width: 80%;
    max-width: 300px;
    margin: 15px auto;
    padding: 15px 25px;
    font-size: clamp(16px, 4vw, 18px);
    border: none;
    border-radius: 25px;
    background: linear-gradient(135deg, #FF4081, #FF9800);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 4px 15px rgba(255, 64, 129, 0.3);
    touch-action: manipulation;
}

button:active {
    transform: scale(0.95);
    box-shadow: 0 2px 8px rgba(255, 64, 129, 0.2);
}

.score-display {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.7);
    padding: 12px 20px;
    border-radius: 15px;
    font-size: clamp(18px, 4vw, 24px);
    font-weight: bold;
    color: #FFD700;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    z-index: 101;
}

.character-select {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 95%;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    z-index: 200;
}

.char-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 20px;
    margin: 20px 0;
}

.char-option {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    padding: 20px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.char-option:hover, .char-option.selected {
    background: rgba(255, 64, 129, 0.2);
    border-color: #FF4081;
    transform: translateY(-5px);
}

.char-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    margin: 0 auto 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 36px;
}

.char-name {
    font-size: clamp(16px, 3.5vw, 20px);
    margin-bottom: 10px;
    color: #fff;
}

.char-ability {
    font-size: clamp(12px, 2.5vw, 14px);
    color: #aaa;
}

.controls-hint {
    position: absolute;
    bottom: 20px;
    left: 0;
    width: 100%;
    text-align: center;
    color: rgba(255, 255, 255, 0.7);
    font-size: clamp(12px, 2.5vw, 14px);
    padding: 0 20px;
}

.game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    z-index: 150;
}

.fullscreen-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
    cursor: pointer;
    z-index: 101;
}

/* å“åº”å¼è°ƒæ•´ */
@media (max-width: 768px) {
    .char-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .ui-panel {
        padding: 20px;
    }
}

@media (max-width: 480px) {
    .char-grid {
        grid-template-columns: 1fr;
    }
    
    button {
        width: 90%;
        padding: 12px 20px;
    }
    
    .score-display {
        top: 10px;
        left: 10px;
        padding: 8px 15px;
        font-size: 16px;
    }
}

/* é˜²æ­¢æ»šåŠ¨ */
.no-scroll {
    overflow: hidden;
    position: fixed;
    width: 100%;
    height: 100%;
}

/* åŠ è½½åŠ¨ç”» */
.loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 20px;
}
</style>
</head>
<body>
<div id="container">
    <canvas id="game"></canvas>
    <div id="ui"></div>
</div>

<script>
// ==================== æ¸¸æˆæ ¸å¿ƒç±» ====================
class Game {
    constructor() {
        this.canvas = document.getElementById('game');
        this.ctx = this.canvas.getContext('2d');
        this.ui = document.getElementById('ui');
        this.container = document.getElementById('container');
        
        this.state = 'start';
        this.score = 0;
        this.best = parseInt(localStorage.getItem('bestScore')) || 0;
        this.speed = 4;
        this.frame = 0;
        this.selectedCharacter = 'çˆ¸çˆ¸';
        this.difficultyLevel = 1;
        this.obstacleSpawnRate = 0.18;
        this.lastBonusTime = 0;
        
        this.player = {
            lane: 0,
            y: 0,
            baseY: 0,
            jumping: false,
            jumpT: 0,
            doubleJumpUsed: false,
            specialCooldown: 0
        };
        
        this.lanes = [-1, 0, 1];
        this.buildings = [];
        this.obstacles = [];
        this.bonuses = [];
        
        this.touchStartX = null;
        this.touchStartY = null;
        this.lastTouchTime = 0;
        
        this.gameLoop = null;
        this.resizeTimeout = null;
        this.lastTime = 0;
        this.accumulator = 0;
        this.delta = 1000 / 60;
        
        // è§¦æ‘¸å®¹é”™é˜ˆå€¼
        this.TOUCH_THRESHOLD = 20;
        
        this.init();
    }

    init() {
        this.setCanvasSize();
        this.initBuildings();
        this.bindEvents();
        this.renderUI();
        this.startGameLoop();
        
        // ç¡®ä¿UIå…ƒç´ å¯ä»¥ç‚¹å‡»
        setTimeout(() => {
            const uiElements = this.ui.querySelectorAll('button, .char-option');
            uiElements.forEach(el => {
                el.style.pointerEvents = 'auto';
            });
        }, 100);
    }

    setCanvasSize() {
        // è·å–å®é™…æ˜¾ç¤ºå°ºå¯¸
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // è®¾ç½®canvasæ˜¾ç¤ºå°ºå¯¸
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        
        // è®¾ç½®canvasç»˜åˆ¶å°ºå¯¸ï¼ˆè€ƒè™‘è®¾å¤‡åƒç´ æ¯”ï¼‰
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = Math.floor(width * dpr);
        this.canvas.height = Math.floor(height * dpr);
        
        // ç¼©æ”¾ä¸Šä¸‹æ–‡
        this.ctx.scale(dpr, dpr);
        
        // æ›´æ–°æ¸¸æˆå‚æ•°
        this.player.baseY = height * 0.7;
        this.player.y = this.player.baseY;
        
        console.log('Canvaså°ºå¯¸:', width + 'x' + height, 'DPR:', dpr);
    }

    initBuildings() {
        this.buildings = [];
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        const height = this.canvas.height / (window.devicePixelRatio || 1);
        
        for (let i = 0; i < 15; i++) {
            this.buildings.push({
                x: Math.random() * width,
                width: 40 + Math.random() * 80,
                height: 80 + Math.random() * 200,
                color: `hsl(${220 + Math.random() * 40}, 60%, ${30 + Math.random() * 20}%)`,
                windows: Math.floor(Math.random() * 8) + 3
            });
        }
    }

    bindEvents() {
        // çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.setCanvasSize();
                this.initBuildings();
            }, 250);
        });

        // è§¦æ‘¸äº‹ä»¶ - ç®€åŒ–ç‰ˆæœ¬ï¼Œç›´æ¥å“åº”
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (this.state !== 'play') return;
            
            const touch = e.touches[0];
            this.touchStartX = touch.clientX;
            this.touchStartY = touch.clientY;
            this.lastTouchTime = Date.now();
            
            // ç›´æ¥è·³è·ƒï¼ˆç®€åŒ–æ“ä½œï¼‰
            if (!this.player.jumping) {
                this.startJump();
            }
        }, { passive: false });

        // è§¦æ‘¸ç§»åŠ¨ç”¨äºæ¢é“
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (this.state !== 'play' || !this.touchStartX) return;
            
            const touch = e.touches[0];
            const dx = touch.clientX - this.touchStartX;
            
            // å·¦å³æ»‘åŠ¨æ¢é“
            if (Math.abs(dx) > 50) {
                if (dx > 0 && this.player.lane < 1) {
                    this.player.lane++;
                    this.touchStartX = touch.clientX; // é‡ç½®èµ·å§‹ç‚¹
                } else if (dx < 0 && this.player.lane > -1) {
                    this.player.lane--;
                    this.touchStartX = touch.clientX; // é‡ç½®èµ·å§‹ç‚¹
                }
            }
        }, { passive: false });

        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (this.state !== 'play') return;
            
            // äºŒæ®µè·³æ£€æµ‹
            if (this.player.jumping && !this.player.doubleJumpUsed && 
                this.characters[this.selectedCharacter].special === 'doubleJump') {
                this.player.jumpT = Math.PI / 2;
                this.player.doubleJumpUsed = true;
            }
            
            this.touchStartX = null;
            this.touchStartY = null;
        }, { passive: false });

        // é”®ç›˜æ§åˆ¶ï¼ˆç”¨äºæµ‹è¯•ï¼‰
        document.addEventListener('keydown', (e) => {
            if (this.state === 'play') {
                if (e.key === 'ArrowLeft' && this.player.lane > -1) this.player.lane--;
                if (e.key === 'ArrowRight' && this.player.lane < 1) this.player.lane++;
                if ((e.key === ' ' || e.key === 'ArrowUp') && !this.player.jumping) {
                    this.startJump();
                }
                e.preventDefault();
            }
        });

        // é˜²æ­¢é¡µé¢æ»šåŠ¨
        document.addEventListener('touchmove', (e) => {
            if (this.state === 'play') {
                e.preventDefault();
            }
        }, { passive: false });

        // ç‚¹å‡»UIåŒºåŸŸ
        this.ui.addEventListener('click', (e) => {
            // UIç‚¹å‡»äº‹ä»¶é€šè¿‡å†’æ³¡å¤„ç†
        });
    }

    startJump() {
        this.player.jumping = true;
        this.player.jumpT = 0;
        this.player.doubleJumpUsed = false;
    }

    startGameLoop() {
        if (this.gameLoop) {
            cancelAnimationFrame(this.gameLoop);
        }
        
        const gameLoop = (currentTime) => {
            if (!this.lastTime) this.lastTime = currentTime;
            
            const deltaTime = currentTime - this.lastTime;
            this.lastTime = currentTime;
            
            // é™åˆ¶æœ€å¤§deltaTime
            const maxDelta = 1000;
            const clampedDelta = Math.min(deltaTime, maxDelta);
            
            this.accumulator += clampedDelta;
            
            while (this.accumulator >= this.delta) {
                this.update(this.delta / 1000);
                this.accumulator -= this.delta;
            }
            
            this.render();
            this.gameLoop = requestAnimationFrame(gameLoop);
        };
        
        this.gameLoop = requestAnimationFrame(gameLoop);
    }

    update(deltaTime) {
        if (this.state !== 'play') return;
        
        this.frame++;
        
        // æ›´æ–°éš¾åº¦
        this.updateDifficulty();
        
        // ç”Ÿæˆéšœç¢ç‰©å’Œå¥–åŠ±
        if (this.frame % Math.max(30, 60 - this.difficultyLevel * 5) === 0) {
            this.spawnObstacle();
        }
        this.spawnBonus();
        
        // æ›´æ–°ç©å®¶ä½ç½®
        if (this.player.jumping) {
            this.player.jumpT += 0.1 * deltaTime * 60;
            const char = this.characters[this.selectedCharacter];
            const jumpHeight = char.special === 'highJump' ? 160 : 120;
            this.player.y = this.player.baseY - Math.sin(this.player.jumpT) * jumpHeight;
            if (this.player.jumpT > Math.PI) {
                this.player.jumping = false;
                this.player.doubleJumpUsed = false;
                this.player.y = this.player.baseY;
            }
        }
        
        // æ›´æ–°éšœç¢ç‰©ä½ç½®
        this.obstacles.forEach(obs => {
            obs.y += this.speed * deltaTime * 60;
            
            if (obs.type === 'movingBall') {
                obs.lane += obs.speedX / (this.canvas.width * 0.25);
                if (obs.lane < -1) {
                    obs.lane = -1;
                    obs.speedX *= -1;
                }
                if (obs.lane > 1) {
                    obs.lane = 1;
                    obs.speedX *= -1;
                }
            }
        });
        
        // æ›´æ–°å¥–åŠ±ä½ç½®
        this.bonuses.forEach(bonus => {
            bonus.y += this.speed * deltaTime * 60;
        });
        
        // æ£€æŸ¥ç¢°æ’
        this.checkCollisions();
        
        // æ¯å¸§å¾—åˆ†
        this.score += 0.1 * deltaTime * 60;
        
        // æ¸…ç†è¶…å‡ºå±å¹•çš„å¯¹è±¡
        this.cleanupObjects();
    }

    render() {
        // æ¸…é™¤ç”»å¸ƒ
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        const height = this.canvas.height / (window.devicePixelRatio || 1);
        this.ctx.clearRect(0, 0, width, height);
        
        if (this.state !== 'play') return;
        
        // ç»˜åˆ¶èƒŒæ™¯
        this.drawBackground();
        
        // ç»˜åˆ¶è½¨é“
        this.drawLanes();
        
        // ç»˜åˆ¶éšœç¢ç‰©
        this.obstacles.forEach(obs => {
            this.drawObstacle(obs);
        });
        
        // ç»˜åˆ¶å¥–åŠ±
        this.bonuses.forEach(bonus => {
            this.drawBonus(bonus);
        });
        
        // ç»˜åˆ¶ç©å®¶
        this.drawPlayer();
        
        // æ›´æ–° UI åˆ†æ•°æ˜¾ç¤º
        this.updateScoreDisplay();
    }

    drawBackground() {
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        const height = this.canvas.height / (window.devicePixelRatio || 1);
        
        // å¤©ç©ºæ¸å˜
        const gradient = this.ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#1a237e');
        gradient.addColorStop(1, '#283593');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, width, height);
        
        // æ˜Ÿæ˜Ÿ
        this.ctx.fillStyle = '#FFFFFF';
        for (let i = 0; i < 30; i++) {
            const x = Math.floor((this.frame * 0.05 + i * 73.7) % width);
            const y = Math.floor((i * 37.3) % height * 0.7);
            this.ctx.beginPath();
            this.ctx.arc(x, y, Math.random() * 1.2 + 0.3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // åŸå¸‚å»ºç­‘
        this.buildings.forEach(building => {
            const x = (building.x - this.frame * 0.3) % (width + building.width) - building.width;
            if (x + building.width > 0) {
                this.ctx.fillStyle = building.color;
                this.ctx.fillRect(x, height - building.height, building.width, building.height);
                
                // çª—æˆ·
                this.ctx.fillStyle = '#FFD740';
                for (let i = 0; i < building.windows; i++) {
                    const wx = Math.floor(x + 10 + (i % 3) * 20);
                    const wy = Math.floor(height - building.height + 20 + Math.floor(i / 3) * 30);
                    if (wy < height - 30) {
                        this.ctx.fillRect(wx, wy, 6, 10);
                    }
                }
            }
        });
        
        // è¡—é“
        this.ctx.fillStyle = '#424242';
        this.ctx.fillRect(0, height * 0.8, width, height * 0.2);
        
        // è¡—é“çº¿
        this.ctx.strokeStyle = '#FFD740';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([20, 15]);
        this.ctx.beginPath();
        this.ctx.moveTo(0, height * 0.85);
        this.ctx.lineTo(width, height * 0.85);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    }

    drawLanes() {
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        this.ctx.lineWidth = 1;
        
        this.lanes.forEach(lane => {
            const x = width / 2 + lane * width * 0.25;
            this.ctx.beginPath();
            this.ctx.moveTo(Math.floor(x), 0);
            this.ctx.lineTo(Math.floor(x), this.canvas.height);
            this.ctx.stroke();
        });
    }

    laneX(lane) {
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        return width / 2 + lane * width * 0.25;
    }

    // å®Œæ•´çš„è§’è‰²å®šä¹‰
    characters = {
        'çˆ¸çˆ¸': {
            color: '#FF9800',
            special: 'doubleJump',
            draw: (ctx, x, y, jumping, frame) => {
                ctx.save();
                ctx.fillStyle = '#FF9800';
                
                // èƒ–èƒ–çš„èº«ä½“
                ctx.beginPath();
                ctx.ellipse(x, y - 20, 25, 35, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // å¤´éƒ¨
                ctx.beginPath();
                ctx.arc(x, y - 55, 18, 0, Math.PI * 2);
                ctx.fill();
                
                // çœ¼ç›
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 6, y - 58, 3, 0, Math.PI * 2);
                ctx.arc(x + 6, y - 58, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // å˜´å·´
                ctx.beginPath();
                ctx.arc(x, y - 50, 8, 0.1, Math.PI - 0.1);
                ctx.stroke();
                
                // ç¯®çƒ
                const ballY = jumping ? y - 15 : y + 5;
                ctx.fillStyle = '#ff5722';
                ctx.beginPath();
                ctx.arc(x + 25, ballY, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        },
        'lucky': {
            color: '#4CAF50',
            special: 'fast',
            draw: (ctx, x, y, jumping, frame) => {
                ctx.save();
                ctx.fillStyle = '#4CAF50';
                
                // èº«ä½“
                ctx.beginPath();
                ctx.ellipse(x, y - 15, 15, 20, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // å¤´éƒ¨
                ctx.beginPath();
                ctx.arc(x, y - 40, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // çœ¼ç›
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(x - 4, y - 42, 4, 0, Math.PI * 2);
                ctx.arc(x + 4, y - 42, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // å¸½å­
                ctx.fillStyle = '#2196F3';
                ctx.beginPath();
                ctx.ellipse(x, y - 48, 15, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç¯®çƒ
                ctx.fillStyle = '#ff5722';
                ctx.beginPath();
                ctx.arc(x + 15, y - 10, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        },
        'åˆ˜å¤§åŠ›': {
            color: '#E91E63',
            special: 'highJump',
            draw: (ctx, x, y, jumping, frame) => {
                ctx.save();
                ctx.fillStyle = '#E91E63';
                
                // èº«ä½“
                ctx.beginPath();
                ctx.ellipse(x, y - 20, 18, 25, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // å¤´éƒ¨
                ctx.beginPath();
                ctx.arc(x, y - 48, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // é•¿å‘
                ctx.beginPath();
                ctx.moveTo(x - 15, y - 48);
                ctx.quadraticCurveTo(x - 25, y - 30, x - 10, y - 20);
                ctx.quadraticCurveTo(x, y - 25, x, y - 35);
                ctx.fill();
                
                // çŒç¯®åŠ¨ä½œ
                const jumpOffset = jumping ? -20 : 0;
                ctx.fillStyle = '#ff5722';
                ctx.beginPath();
                ctx.arc(x + 25, y + jumpOffset, 9, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        },
        'nn': {
            color: '#9C27B0',
            special: 'slowTime',
            draw: (ctx, x, y, jumping, frame) => {
                ctx.save();
                ctx.fillStyle = '#9C27B0';
                
                // èº«ä½“
                ctx.beginPath();
                ctx.ellipse(x, y - 15, 22, 28, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // å¤´éƒ¨
                ctx.beginPath();
                ctx.arc(x, y - 45, 16, 0, Math.PI * 2);
                ctx.fill();
                
                // é“¶å‘
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.ellipse(x, y - 58, 20, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // è€èŠ±é•œ
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x - 8, y - 43, 6, 0, Math.PI * 2);
                ctx.arc(x + 8, y - 43, 6, 0, Math.PI * 2);
                ctx.moveTo(x - 2, y - 43);
                ctx.lineTo(x + 2, y - 43);
                ctx.stroke();
                
                // ç¯®çƒ
                ctx.fillStyle = '#ff5722';
                ctx.beginPath();
                ctx.arc(x + 20, y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
    };

    drawPlayer() {
        const char = this.characters[this.selectedCharacter];
        const x = Math.floor(this.laneX(this.player.lane));
        const y = Math.floor(this.player.y);
        char.draw(this.ctx, x, y, this.player.jumping, this.frame);
    }

    drawObstacle(obstacle) {
        const x = Math.floor(this.laneX(obstacle.lane));
        const y = Math.floor(obstacle.y);
        
        this.ctx.save();
        
        if (obstacle.type === 'hoop') {
            // ç¯®ç­
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.fillRect(x - 40, y, 80, 40);
            
            this.ctx.fillStyle = '#FF5722';
            this.ctx.beginPath();
            this.ctx.ellipse(x, y + 20, 25, 10, 0, 0, Math.PI * 2);
            this.ctx.fill();
        } else if (obstacle.type === 'courtLine') {
            // çƒåœºçº¿
            const width = this.canvas.width / (window.devicePixelRatio || 1);
            this.ctx.strokeStyle = '#FFFFFF';
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([15, 10]);
            this.ctx.beginPath();
            this.ctx.moveTo(0, y + 7);
            this.ctx.lineTo(width, y + 7);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        } else if (obstacle.type === 'movingBall') {
            // ç§»åŠ¨ç¯®çƒ
            this.ctx.fillStyle = '#FF5722';
            this.ctx.beginPath();
            this.ctx.arc(x, y, 15, 0, Math.PI * 2);
            this.ctx.fill();
        } else if (obstacle.type === 'threePointLine') {
            // ä¸‰åˆ†çº¿
            this.ctx.strokeStyle = '#FFD700';
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(x, y + 25, 50, Math.PI, Math.PI * 2);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }

    drawBonus(bonus) {
        const x = Math.floor(this.laneX(bonus.lane));
        const y = Math.floor(bonus.y);
        
        this.ctx.fillStyle = bonus.type === 'score' ? '#FFD700' : '#00E5FF';
        this.ctx.beginPath();
        this.ctx.arc(x, y, 12, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.fillStyle = '#000';
        this.ctx.font = 'bold 16px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(bonus.type === 'score' ? 'â˜…' : 'âš¡', x, y);
    }

    updateScoreDisplay() {
        const scoreEl = document.querySelector('.score-display');
        if (scoreEl) {
            scoreEl.textContent = `å¾—åˆ†: ${Math.floor(this.score)}`;
        }
    }

    updateDifficulty() {
        this.difficultyLevel = Math.floor(this.score / 50) + 1;
        this.speed = 4 + this.difficultyLevel * 0.5;
        this.obstacleSpawnRate = 0.18 + this.difficultyLevel * 0.02;
    }

    spawnObstacle() {
        if (Math.random() < this.obstacleSpawnRate) {
            const types = ['hoop', 'courtLine', 'movingBall', 'threePointLine'];
            let type = types[Math.floor(Math.random() * types.length)];
            
            if (this.difficultyLevel >= 3 && Math.random() < 0.4) {
                type = 'movingBall';
            }
            
            const lane = this.lanes[Math.floor(Math.random() * this.lanes.length)];
            const obstacle = {
                type: type,
                lane: lane,
                y: -100,
                passed: false
            };
            
            if (type === 'movingBall') {
                obstacle.speedX = (Math.random() - 0.5) * 6;
            }
            
            this.obstacles.push(obstacle);
        }
    }

    spawnBonus() {
        if (this.frame - this.lastBonusTime > 300 && Math.random() < 0.05) {
            this.bonuses.push({
                type: Math.random() < 0.7 ? 'score' : 'speedBoost',
                lane: this.lanes[Math.floor(Math.random() * this.lanes.length)],
                y: -50
            });
            this.lastBonusTime = this.frame;
        }
    }

    checkCollisions() {
        const playerX = this.laneX(this.player.lane);
        const playerY = this.player.y;
        
        // æ£€æŸ¥éšœç¢ç‰©ç¢°æ’
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const obs = this.obstacles[i];
            const obsX = this.laneX(obs.lane);
            
            if (!obs.passed && obs.y > playerY - 50 && obs.y < playerY + 50) {
                let collision = false;
                const dx = playerX - obsX;
                const dy = playerY - obs.y;
                
                if (obs.type === 'hoop') {
                    collision = Math.abs(dx) < 40 && Math.abs(dy - 20) < 30;
                } else if (obs.type === 'courtLine') {
                    collision = !this.player.jumping && Math.abs(dy - 7) < 30;
                } else if (obs.type === 'movingBall') {
                    collision = Math.sqrt(dx * dx + dy * dy) < 25;
                } else if (obs.type === 'threePointLine') {
                    collision = Math.abs(dx) < 60 && Math.abs(dy - 25) < 25 && !this.player.jumping;
                }
                
                if (collision) {
                    this.gameOver();
                    return;
                }
                
                if (obs.y > playerY && !obs.passed) {
                    obs.passed = true;
                    this.score += 5;
                }
            }
        }
        
        // æ£€æŸ¥å¥–åŠ±ç¢°æ’
        for (let i = this.bonuses.length - 1; i >= 0; i--) {
            const bonus = this.bonuses[i];
            const bonusX = this.laneX(bonus.lane);
            const dx = playerX - bonusX;
            const dy = playerY - bonus.y;
            
            if (Math.sqrt(dx * dx + dy * dy) < 25) {
                if (bonus.type === 'score') {
                    this.score += 50;
                } else if (bonus.type === 'speedBoost') {
                    this.speed += 2;
                    setTimeout(() => {
                        if (this.speed > 4) this.speed -= 2;
                    }, 3000);
                }
                this.bonuses.splice(i, 1);
            }
        }
    }

    cleanupObjects() {
        const height = this.canvas.height / (window.devicePixelRatio || 1);
        
        // æ¸…ç†éšœç¢ç‰©
        this.obstacles = this.obstacles.filter(obs => obs.y < height + 100);
        
        // æ¸…ç†å¥–åŠ±
        this.bonuses = this.bonuses.filter(bonus => bonus.y < height + 50);
    }

    gameOver() {
        this.state = 'over';
        this.best = Math.max(this.best, Math.floor(this.score));
        localStorage.setItem('bestScore', this.best);
        this.renderUI();
    }

    renderUI() {
        // æ¸…ç©ºUI
        this.ui.innerHTML = '';
        
        if (this.state === 'start') {
            this.ui.innerHTML = `
                <div class="ui-panel" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 90%; max-width: 500px;">
                    <h1>ğŸ€ å®¶åº­ç¯®çƒè·‘é…· ğŸ€</h1>
                    <p>å·¦å³æ»‘åŠ¨æ¢é“ Â· ç‚¹å‡»å±å¹•è·³è·ƒ Â· é¿å¼€éšœç¢ç‰©</p>
                    <button id="start-btn">å¼€å§‹æ¸¸æˆ</button>
                    <p>æœ€é«˜åˆ†ï¼š${this.best}</p>
                    <p style="color: #aaa; font-size: 14px; margin-top: 20px;">æç¤ºï¼šç‚¹å‡»å¼€å§‹æ¸¸æˆåé€‰æ‹©è§’è‰²</p>
                </div>
            `;
            
            // ç»‘å®šå¼€å§‹æŒ‰é’®äº‹ä»¶
            setTimeout(() => {
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        this.showCharacterSelect();
                    });
                }
            }, 50);
            
        } else if (this.state === 'character') {
            this.ui.innerHTML = `
                <div class="character-select ui-panel">
                    <h2>é€‰æ‹©ä½ çš„è§’è‰²</h2>
                    <div class="char-grid">
                        <div class="char-option ${this.selectedCharacter === 'çˆ¸çˆ¸' ? 'selected' : ''}" 
                             data-char="çˆ¸çˆ¸">
                            <div class="char-avatar" style="background: #FF9800;">ğŸ‘¨</div>
                            <div class="char-name">çˆ¸çˆ¸</div>
                            <div class="char-ability">äºŒæ®µè·³èƒ½åŠ›</div>
                        </div>
                        <div class="char-option ${this.selectedCharacter === 'lucky' ? 'selected' : ''}" 
                             data-char="lucky">
                            <div class="char-avatar" style="background: #4CAF50;">ğŸ‘¦</div>
                            <div class="char-name">lucky</div>
                            <div class="char-ability">ç§»åŠ¨é€Ÿåº¦æ›´å¿«</div>
                        </div>
                        <div class="char-option ${this.selectedCharacter === 'åˆ˜å¤§åŠ›' ? 'selected' : ''}" 
                             data-char="åˆ˜å¤§åŠ›">
                            <div class="char-avatar" style="background: #E91E63;">ğŸ‘§</div>
                            <div class="char-name">åˆ˜å¤§åŠ›</div>
                            <div class="char-ability">è·³è·ƒé«˜åº¦æ›´é«˜</div>
                        </div>
                        <div class="char-option ${this.selectedCharacter === 'nn' ? 'selected' : ''}" 
                             data-char="nn">
                            <div class="char-avatar" style="background: #9C27B0;">ğŸ‘µ</div>
                            <div class="char-name">nn</div>
                            <div class="char-ability">å¶å°”å‡ç¼“æ—¶é—´</div>
                        </div>
                    </div>
                    <button id="confirm-char">å¼€å§‹è·‘é…·</button>
                </div>
            `;
            
            // ç»‘å®šè§’è‰²é€‰æ‹©äº‹ä»¶
            setTimeout(() => {
                // è§’è‰²é€‰æ‹©
                const charOptions = document.querySelectorAll('.char-option');
                charOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        const char = option.getAttribute('data-char');
                        this.selectCharacter(char);
                        
                        // æ›´æ–°é€‰ä¸­çŠ¶æ€
                        charOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                    });
                });
                
                // ç¡®è®¤æŒ‰é’®
                const confirmBtn = document.getElementById('confirm-char');
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', () => {
                        this.startGame();
                    });
                }
            }, 50);
            
        } else if (this.state === 'play') {
            this.ui.innerHTML = `
                <div class="score-display">å¾—åˆ†: ${Math.floor(this.score)}</div>
                <div class="controls-hint">
                    è§’è‰²: ${this.selectedCharacter} | éš¾åº¦: ${this.difficultyLevel}
                </div>
            `;
            
        } else if (this.state === 'over') {
            const finalScore = Math.floor(this.score);
            let comment = '';
            if (finalScore < 50) comment = 'ç»§ç»­ç»ƒä¹ ï¼';
            else if (finalScore < 100) comment = 'ä¸é”™å“¦ï¼';
            else if (finalScore < 200) comment = 'å¤ªæ£’äº†ï¼';
            else comment = 'ä½ æ˜¯ç¯®çƒå¤§å¸ˆï¼';
            
            this.ui.innerHTML = `
                <div class="game-over ui-panel">
                    <h2>æ¸¸æˆç»“æŸ</h2>
                    <p>å¾—åˆ†ï¼š${finalScore}</p>
                    <p>${comment}</p>
                    <p>æœ€é«˜åˆ†ï¼š${this.best}</p>
                    <button id="restart-btn">å†æ¥ä¸€å±€</button>
                    <button id="change-char-btn">é€‰æ‹©è§’è‰²</button>
                </div>
            `;
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            setTimeout(() => {
                const restartBtn = document.getElementById('restart-btn');
                const changeCharBtn = document.getElementById('change-char-btn');
                
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        this.startGame();
                    });
                }
                
                if (changeCharBtn) {
                    changeCharBtn.addEventListener('click', () => {
                        this.showCharacterSelect();
                    });
                }
            }, 50);
        }
        
        // æ·»åŠ å…¨å±æŒ‰é’®
        this.addFullscreenButton();
    }

    addFullscreenButton() {
        const existingBtn = document.querySelector('.fullscreen-btn');
        if (existingBtn) existingBtn.remove();
        
        const fullscreenBtn = document.createElement('div');
        fullscreenBtn.className = 'fullscreen-btn';
        fullscreenBtn.innerHTML = 'â›¶';
        fullscreenBtn.addEventListener('click', this.toggleFullscreen.bind(this));
        this.container.appendChild(fullscreenBtn);
    }

    toggleFullscreen() {
        const doc = window.document;
        const docEl = doc.documentElement;
        
        const requestFullScreen = docEl.requestFullscreen || 
                                 docEl.mozRequestFullScreen || 
                                 docEl.webkitRequestFullScreen || 
                                 docEl.msRequestFullscreen;
        
        const exitFullScreen = doc.exitFullscreen || 
                              doc.mozCancelFullScreen || 
                              doc.webkitExitFullscreen || 
                              doc.msExitFullscreen;
        
        if (!doc.fullscreenElement && !doc.mozFullScreenElement && 
            !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            requestFullScreen.call(docEl).catch(err => {
                console.log('å…¨å±å¤±è´¥:', err);
            });
        } else {
            exitFullScreen.call(doc);
        }
    }

    selectCharacter(char) {
        this.selectedCharacter = char;
        console.log('é€‰æ‹©è§’è‰²:', char);
    }

    showCharacterSelect() {
        this.state = 'character';
        this.renderUI();
    }

    startGame() {
        this.state = 'play';
        this.score = 0;
        this.speed = 4;
        this.frame = 0;
        this.obstacles = [];
        this.bonuses = [];
        this.player.lane = 0;
        this.player.jumping = false;
        this.player.doubleJumpUsed = false;
        this.player.specialCooldown = 0;
        this.difficultyLevel = 1;
        this.obstacleSpawnRate = 0.18;
        this.initBuildings();
        this.renderUI();
        
        console.log('å¼€å§‹æ¸¸æˆï¼Œè§’è‰²:', this.selectedCharacter);
    }
}

// ==================== å…¨å±€åˆå§‹åŒ– ====================
let game;

window.addEventListener('load', () => {
    // è®¾ç½®å…¨å±æ ·å¼
    document.documentElement.style.height = '100%';
    document.body.style.height = '100%';
    
    // ç¦ç”¨åŒå‡»ç¼©æ”¾
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
    
    // åˆå§‹åŒ–æ¸¸æˆ
    game = new Game();
    
    // é˜»æ­¢å³é”®èœå•
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
    
    console.log('æ¸¸æˆåˆå§‹åŒ–å®Œæˆ');
});

// å…¨å±€å¯¼å‡ºæ¸¸æˆå®ä¾‹ä¾›è°ƒè¯•
window.game = game;
</script>
</body>
</html>
