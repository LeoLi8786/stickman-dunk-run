<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>å®¶åº­ç¯®çƒè·‘é…·</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

body {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    touch-action: none;
}

#container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #1a237e;
}

#game {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
    display: block;
}

#ui {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
    pointer-events: none;
}

.ui-panel {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.85);
    border-radius: 20px;
    padding: 25px;
    max-width: 90%;
    margin: 0 auto;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.1);
}

h1, h2, h3 {
    color: #fff;
    text-align: center;
    margin-bottom: 20px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

h1 {
    font-size: clamp(24px, 6vw, 36px);
    color: #FFD700;
}

h2 {
    font-size: clamp(20px, 5vw, 28px);
}

h3 {
    font-size: clamp(18px, 4vw, 24px);
}

p {
    color: #fff;
    text-align: center;
    margin: 10px 0;
    font-size: clamp(14px, 3.5vw, 16px);
    line-height: 1.5;
}

button {
    display: block;
    width: 80%;
    max-width: 300px;
    margin: 15px auto;
    padding: 15px 25px;
    font-size: clamp(16px, 4vw, 18px);
    border: none;
    border-radius: 25px;
    background: linear-gradient(135deg, #FF4081, #FF9800);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 4px 15px rgba(255, 64, 129, 0.3);
    touch-action: manipulation;
}

button:active {
    transform: scale(0.95);
    box-shadow: 0 2px 8px rgba(255, 64, 129, 0.2);
}

.score-display {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.7);
    padding: 12px 20px;
    border-radius: 15px;
    font-size: clamp(18px, 4vw, 24px);
    font-weight: bold;
    color: #FFD700;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    z-index: 101;
}

.character-select {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 95%;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    z-index: 200;
}

.char-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 20px;
    margin: 20px 0;
}

.char-option {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    padding: 20px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.char-option:hover, .char-option.selected {
    background: rgba(255, 64, 129, 0.2);
    border-color: #FF4081;
    transform: translateY(-5px);
}

.char-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    margin: 0 auto 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 36px;
}

.char-name {
    font-size: clamp(16px, 3.5vw, 20px);
    margin-bottom: 10px;
    color: #fff;
}

.char-ability {
    font-size: clamp(12px, 2.5vw, 14px);
    color: #aaa;
}

.controls-hint {
    position: absolute;
    bottom: 20px;
    left: 0;
    width: 100%;
    text-align: center;
    color: rgba(255, 255, 255, 0.7);
    font-size: clamp(12px, 2.5vw, 14px);
    padding: 0 20px;
}

.game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    z-index: 150;
}

.fullscreen-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
    cursor: pointer;
    z-index: 101;
}

/* å“åº”å¼è°ƒæ•´ */
@media (max-width: 768px) {
    .char-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .ui-panel {
        padding: 20px;
    }
}

@media (max-width: 480px) {
    .char-grid {
        grid-template-columns: 1fr;
    }
    
    button {
        width: 90%;
        padding: 12px 20px;
    }
    
    .score-display {
        top: 10px;
        left: 10px;
        padding: 8px 15px;
        font-size: 16px;
    }
}

/* é˜²æ­¢æ»šåŠ¨ */
.no-scroll {
    overflow: hidden;
    position: fixed;
    width: 100%;
    height: 100%;
}

/* åŠ è½½åŠ¨ç”» */
.loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 20px;
}

/* æ€§èƒ½ä¼˜åŒ– */
.performance-hint {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}
</style>
</head>
<body class="no-scroll">
<div id="container">
    <canvas id="game"></canvas>
    <div id="ui"></div>
</div>

<script>
// æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ requestAnimationFrame çš„ç¨³å®šç‰ˆæœ¬
class GameLoop {
    constructor(update, render) {
        this.update = update;
        this.render = render;
        this.rafId = null;
        this.lastTime = 0;
        this.accumulator = 0;
        this.delta = 1000 / 60; // 60 FPS
        this.running = false;
    }

    start() {
        if (!this.running) {
            this.running = true;
            this.lastTime = performance.now();
            this.rafId = requestAnimationFrame(this.loop.bind(this));
        }
    }

    stop() {
        if (this.running) {
            this.running = false;
            if (this.rafId) {
                cancelAnimationFrame(this.rafId);
                this.rafId = null;
            }
        }
    }

    loop(currentTime) {
        if (!this.running) return;

        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;

        // é™åˆ¶æœ€å¤§ deltaTime é˜²æ­¢å¡é¡¿å¯¼è‡´çš„å·¨å¤§è·³è·ƒ
        const maxDelta = 1000; // 1ç§’
        const clampedDelta = Math.min(deltaTime, maxDelta);

        this.accumulator += clampedDelta;

        while (this.accumulator >= this.delta) {
            this.update(this.delta / 1000);
            this.accumulator -= this.delta;
        }

        this.render();

        this.rafId = requestAnimationFrame(this.loop.bind(this));
    }
}

// åˆå§‹åŒ–æ¸¸æˆ
class Game {
    constructor() {
        this.canvas = document.getElementById('game');
        this.ctx = this.canvas.getContext('2d');
        this.ui = document.getElementById('ui');
        
        this.state = 'start';
        this.score = 0;
        this.best = localStorage.getItem('bestScore') || 0;
        this.speed = 4;
        this.frame = 0;
        this.selectedCharacter = 'çˆ¸çˆ¸';
        this.difficultyLevel = 1;
        this.obstacleSpawnRate = 0.18;
        this.lastBonusTime = 0;
        
        this.player = {
            lane: 0,
            y: 0,
            baseY: 0,
            jumping: false,
            jumpT: 0,
            doubleJumpUsed: false,
            specialCooldown: 0
        };
        
        this.lanes = [-1, 0, 1];
        this.buildings = [];
        this.obstacles = [];
        this.bonuses = [];
        
        this.touchStartX = null;
        this.touchStartY = null;
        this.lastTouchTime = 0;
        
        this.gameLoop = null;
        this.resizeTimeout = null;
        
        this.init();
    }

    init() {
        // è®¾ç½® canvas ä¸ºè®¾å¤‡åƒç´ æ¯”
        this.setCanvasSize();
        
        // åˆå§‹åŒ–æ¸¸æˆæ•°æ®
        this.initBuildings();
        
        // ç»‘å®šäº‹ä»¶
        this.bindEvents();
        
        // åˆå§‹æ¸²æŸ“
        this.renderUI();
        
        // å¼€å§‹æ¸¸æˆå¾ªç¯
        this.startGameLoop();
    }

    setCanvasSize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2); // é™åˆ¶æœ€å¤§ DPR ä¸º 2
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // è®¾ç½® canvas æ˜¾ç¤ºå°ºå¯¸
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        
        // è®¾ç½® canvas å®é™…æ¸²æŸ“å°ºå¯¸
        this.canvas.width = Math.floor(width * dpr);
        this.canvas.height = Math.floor(height * dpr);
        
        // ç¼©æ”¾ä¸Šä¸‹æ–‡ä»¥åŒ¹é… DPR
        this.ctx.scale(dpr, dpr);
        
        // æ›´æ–°æ¸¸æˆå‚æ•°
        this.player.baseY = height * 0.7;
        this.player.y = this.player.baseY;
        
        // é‡æ–°åˆå§‹åŒ–å»ºç­‘
        this.initBuildings();
    }

    initBuildings() {
        this.buildings = [];
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        const height = this.canvas.height / (window.devicePixelRatio || 1);
        
        for (let i = 0; i < 15; i++) {
            this.buildings.push({
                x: Math.random() * width,
                width: 40 + Math.random() * 80,
                height: 80 + Math.random() * 200,
                color: `hsl(${220 + Math.random() * 40}, 60%, ${30 + Math.random() * 20}%)`,
                windows: Math.floor(Math.random() * 8) + 3
            });
        }
    }

    bindEvents() {
        // çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', () => {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.setCanvasSize();
            }, 100);
        });

        // è§¦æ‘¸äº‹ä»¶
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            this.touchStartX = touch.clientX;
            this.touchStartY = touch.clientY;
            this.lastTouchTime = Date.now();
        }, { passive: false });

        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (this.state !== 'play') return;
            
            const touch = e.changedTouches[0];
            const dx = touch.clientX - this.touchStartX;
            const dy = touch.clientY - this.touchStartY;
            const timeDiff = Date.now() - this.lastTouchTime;
            
            // é˜²æ­¢è¯¯è§¦
            if (timeDiff > 1000) return;
            
            // åˆ¤æ–­æ˜¯æ»‘åŠ¨è¿˜æ˜¯ç‚¹å‡»
            if (Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                // æ»‘åŠ¨æ¢é“
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30 && this.player.lane < 1) this.player.lane++;
                    if (dx < -30 && this.player.lane > -1) this.player.lane--;
                }
            } else {
                // ç‚¹å‡»è·³è·ƒ
                if (!this.player.jumping) {
                    this.startJump();
                } else if (this.player.jumping && !this.player.doubleJumpUsed && 
                          this.characters[this.selectedCharacter].special === 'doubleJump') {
                    // äºŒæ®µè·³
                    this.player.jumpT = Math.PI / 2;
                    this.player.doubleJumpUsed = true;
                }
            }
            
            this.touchStartX = null;
            this.touchStartY = null;
        }, { passive: false });

        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            if (this.state === 'play') {
                if (e.key === 'ArrowLeft' && this.player.lane > -1) this.player.lane--;
                if (e.key === 'ArrowRight' && this.player.lane < 1) this.player.lane++;
                if ((e.key === ' ' || e.key === 'ArrowUp') && !this.player.jumping) {
                    this.startJump();
                }
            }
            
            // é˜»æ­¢ç©ºæ ¼é”®æ»šåŠ¨é¡µé¢
            if (e.key === ' ') {
                e.preventDefault();
            }
        });

        // é˜²æ­¢é¡µé¢æ»šåŠ¨
        document.addEventListener('touchmove', (e) => {
            if (this.state === 'play') {
                e.preventDefault();
            }
        }, { passive: false });
    }

    startJump() {
        this.player.jumping = true;
        this.player.jumpT = 0;
        this.player.doubleJumpUsed = false;
    }

    startGameLoop() {
        if (this.gameLoop) {
            this.gameLoop.stop();
        }
        
        this.gameLoop = new GameLoop(
            (deltaTime) => this.update(deltaTime),
            () => this.render()
        );
        
        this.gameLoop.start();
    }

    update(deltaTime) {
        if (this.state !== 'play') return;
        
        this.frame++;
        
        // æ›´æ–°éš¾åº¦
        this.updateDifficulty();
        
        // ç”Ÿæˆéšœç¢ç‰©å’Œå¥–åŠ±
        if (this.frame % Math.max(30, 60 - this.difficultyLevel * 5) === 0) {
            this.spawnObstacle();
        }
        this.spawnBonus();
        
        // æ›´æ–°ç©å®¶ä½ç½®
        if (this.player.jumping) {
            this.player.jumpT += 0.1 * deltaTime * 60;
            const char = this.characters[this.selectedCharacter];
            const jumpHeight = char.special === 'highJump' ? 160 : 120;
            this.player.y = this.player.baseY - Math.sin(this.player.jumpT) * jumpHeight;
            if (this.player.jumpT > Math.PI) {
                this.player.jumping = false;
                this.player.doubleJumpUsed = false;
                this.player.y = this.player.baseY;
            }
        }
        
        // æ›´æ–°éšœç¢ç‰©ä½ç½®
        this.obstacles.forEach(obs => {
            obs.y += this.speed * deltaTime * 60;
            
            if (obs.type === 'movingBall') {
                obs.lane += obs.speedX / (this.canvas.width * 0.25);
                if (obs.lane < -1) {
                    obs.lane = -1;
                    obs.speedX *= -1;
                }
                if (obs.lane > 1) {
                    obs.lane = 1;
                    obs.speedX *= -1;
                }
            }
        });
        
        // æ›´æ–°å¥–åŠ±ä½ç½®
        this.bonuses.forEach(bonus => {
            bonus.y += this.speed * deltaTime * 60;
        });
        
        // æ£€æŸ¥ç¢°æ’
        this.checkCollisions();
        
        // æ¯å¸§å¾—åˆ†
        this.score += 0.1 * deltaTime * 60;
        
        // æ¸…ç†è¶…å‡ºå±å¹•çš„å¯¹è±¡
        this.cleanupObjects();
    }

    render() {
        // æ¸…é™¤ç”»å¸ƒ
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        const height = this.canvas.height / (window.devicePixelRatio || 1);
        this.ctx.clearRect(0, 0, width, height);
        
        if (this.state !== 'play') return;
        
        // ç»˜åˆ¶èƒŒæ™¯
        this.drawBackground();
        
        // ç»˜åˆ¶è½¨é“
        this.drawLanes();
        
        // ç»˜åˆ¶éšœç¢ç‰©
        this.obstacles.forEach(obs => {
            this.drawObstacle(obs);
        });
        
        // ç»˜åˆ¶å¥–åŠ±
        this.bonuses.forEach(bonus => {
            this.drawBonus(bonus);
        });
        
        // ç»˜åˆ¶ç©å®¶
        this.drawPlayer();
        
        // æ›´æ–° UI åˆ†æ•°æ˜¾ç¤º
        this.updateScoreDisplay();
    }

    drawBackground() {
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        const height = this.canvas.height / (window.devicePixelRatio || 1);
        
        // å¤©ç©ºæ¸å˜
        const gradient = this.ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#1a237e');
        gradient.addColorStop(1, '#283593');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, width, height);
        
        // æ˜Ÿæ˜Ÿï¼ˆä½¿ç”¨æ•´æ•°åæ ‡é¿å…æŠ–åŠ¨ï¼‰
        this.ctx.fillStyle = '#FFFFFF';
        for (let i = 0; i < 30; i++) {
            const x = Math.floor((this.frame * 0.05 + i * 73.7) % width);
            const y = Math.floor((i * 37.3) % height * 0.7);
            this.ctx.beginPath();
            this.ctx.arc(x, y, Math.random() * 1.2 + 0.3, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        // åŸå¸‚å»ºç­‘
        this.buildings.forEach(building => {
            const x = (building.x - this.frame * 0.3) % (width + building.width) - building.width;
            if (x + building.width > 0) {
                this.ctx.fillStyle = building.color;
                this.ctx.fillRect(x, height - building.height, building.width, building.height);
                
                // çª—æˆ·
                this.ctx.fillStyle = '#FFD740';
                for (let i = 0; i < building.windows; i++) {
                    const wx = Math.floor(x + 10 + (i % 3) * 20);
                    const wy = Math.floor(height - building.height + 20 + Math.floor(i / 3) * 30);
                    if (wy < height - 30) {
                        this.ctx.fillRect(wx, wy, 6, 10);
                    }
                }
            }
        });
        
        // è¡—é“
        this.ctx.fillStyle = '#424242';
        this.ctx.fillRect(0, height * 0.8, width, height * 0.2);
        
        // è¡—é“çº¿
        this.ctx.strokeStyle = '#FFD740';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([20, 15]);
        this.ctx.beginPath();
        this.ctx.moveTo(0, height * 0.85);
        this.ctx.lineTo(width, height * 0.85);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
    }

    drawLanes() {
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        this.ctx.lineWidth = 1;
        
        this.lanes.forEach(lane => {
            const x = width / 2 + lane * width * 0.25;
            this.ctx.beginPath();
            this.ctx.moveTo(Math.floor(x), 0);
            this.ctx.lineTo(Math.floor(x), this.canvas.height);
            this.ctx.stroke();
        });
    }

    laneX(lane) {
        const width = this.canvas.width / (window.devicePixelRatio || 1);
        return width / 2 + lane * width * 0.25;
    }

    // è§’è‰²å®šä¹‰å’Œç»˜å›¾æ–¹æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
    characters = {
        'çˆ¸çˆ¸': {
            color: '#FF9800',
            special: 'doubleJump',
            draw: (ctx, x, y, jumping, frame) => {
                // ç®€åŒ–çš„ç»˜å›¾é€»è¾‘
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.arc(x, y - 20, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FF5722';
                ctx.beginPath();
                ctx.arc(x + 15, y - (jumping ? 15 : 5), 8, 0, Math.PI * 2);
                ctx.fill();
            }
        },
        // å…¶ä»–è§’è‰²ç±»ä¼¼ç®€åŒ–
    };

    drawPlayer() {
        const char = this.characters[this.selectedCharacter];
        const x = this.laneX(this.player.lane);
        char.draw(this.ctx, Math.floor(x), Math.floor(this.player.y), this.player.jumping, this.frame);
    }

    drawObstacle(obstacle) {
        const x = this.laneX(obstacle.lane);
        const type = obstacle.type;
        
        this.ctx.save();
        
        if (type === 'hoop') {
            // ç¯®ç­
            this.ctx.fillStyle = '#FFFFFF';
            this.ctx.fillRect(Math.floor(x - 40), Math.floor(obstacle.y), 80, 40);
            
            this.ctx.fillStyle = '#FF5722';
            this.ctx.beginPath();
            this.ctx.ellipse(Math.floor(x), Math.floor(obstacle.y + 20), 25, 10, 0, 0, Math.PI * 2);
            this.ctx.fill();
        } else if (type === 'courtLine') {
            // çƒåœºçº¿
            this.ctx.strokeStyle = '#FFFFFF';
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([15, 10]);
            this.ctx.beginPath();
            this.ctx.moveTo(0, Math.floor(obstacle.y + 7));
            this.ctx.lineTo(this.canvas.width, Math.floor(obstacle.y + 7));
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        } else if (type === 'movingBall') {
            // ç§»åŠ¨ç¯®çƒ
            this.ctx.fillStyle = '#FF5722';
            this.ctx.beginPath();
            this.ctx.arc(Math.floor(x), Math.floor(obstacle.y), 15, 0, Math.PI * 2);
            this.ctx.fill();
        } else if (type === 'threePointLine') {
            // ä¸‰åˆ†çº¿
            this.ctx.strokeStyle = '#FFD700';
            this.ctx.lineWidth = 4;
            this.ctx.beginPath();
            this.ctx.arc(Math.floor(x), Math.floor(obstacle.y + 25), 50, Math.PI, Math.PI * 2);
            this.ctx.stroke();
        }
        
        this.ctx.restore();
    }

    drawBonus(bonus) {
        const x = this.laneX(bonus.lane);
        
        this.ctx.fillStyle = bonus.type === 'score' ? '#FFD700' : '#00E5FF';
        this.ctx.beginPath();
        this.ctx.arc(Math.floor(x), Math.floor(bonus.y), 12, 0, Math.PI * 2);
        this.ctx.fill();
        
        this.ctx.fillStyle = '#000';
        this.ctx.font = 'bold 16px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(bonus.type === 'score' ? 'â˜…' : 'âš¡', Math.floor(x), Math.floor(bonus.y));
    }

    updateScoreDisplay() {
        const scoreEl = document.querySelector('.score-display');
        if (scoreEl) {
            scoreEl.textContent = `å¾—åˆ†: ${Math.floor(this.score)}`;
        }
    }

    updateDifficulty() {
        this.difficultyLevel = Math.floor(this.score / 50) + 1;
        this.speed = 4 + this.difficultyLevel * 0.5;
        this.obstacleSpawnRate = 0.18 + this.difficultyLevel * 0.02;
        
        if (this.characters[this.selectedCharacter].special === 'slowTime' && this.player.specialCooldown <= 0) {
            if (Math.floor(this.score) % 100 === 0 && this.score > 0) {
                this.speed -= 2;
                this.player.specialCooldown = 60;
            }
        }
        
        if (this.player.specialCooldown > 0) this.player.specialCooldown--;
    }

    spawnObstacle() {
        if (Math.random() < this.obstacleSpawnRate) {
            const types = ['hoop', 'courtLine', 'movingBall', 'threePointLine'];
            let type = types[Math.floor(Math.random() * types.length)];
            
            if (this.difficultyLevel >= 3 && Math.random() < 0.4) {
                type = 'movingBall';
            }
            
            const lane = this.lanes[Math.floor(Math.random() * this.lanes.length)];
            const obstacle = {
                type: type,
                lane: lane,
                y: -100,
                passed: false,
                id: Date.now() + Math.random()
            };
            
            if (type === 'movingBall') {
                obstacle.speedX = (Math.random() - 0.5) * 6;
            }
            
            this.obstacles.push(obstacle);
        }
    }

    spawnBonus() {
        if (this.frame - this.lastBonusTime > 300 && Math.random() < 0.05) {
            this.bonuses.push({
                type: Math.random() < 0.7 ? 'score' : 'speedBoost',
                lane: this.lanes[Math.floor(Math.random() * this.lanes.length)],
                y: -50
            });
            this.lastBonusTime = this.frame;
        }
    }

    checkCollisions() {
        const playerX = this.laneX(this.player.lane);
        
        // æ£€æŸ¥éšœç¢ç‰©ç¢°æ’
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const obs = this.obstacles[i];
            const obsX = this.laneX(obs.lane);
            
            if (!obs.passed && obs.y > this.player.y - 50 && obs.y < this.player.y + 50) {
                let collision = false;
                const dx = playerX - obsX;
                const dy = this.player.y - obs.y;
                
                if (obs.type === 'hoop') {
                    collision = Math.abs(dx) < 40 && Math.abs(dy - 20) < 30;
                } else if (obs.type === 'courtLine') {
                    collision = !this.player.jumping && Math.abs(dy - 7) < 30;
                } else if (obs.type === 'movingBall') {
                    collision = Math.sqrt(dx * dx + dy * dy) < 25;
                } else if (obs.type === 'threePointLine') {
                    collision = Math.abs(dx) < 60 && Math.abs(dy - 25) < 25 && !this.player.jumping;
                }
                
                if (collision) {
                    this.gameOver();
                    return;
                }
                
                if (obs.y > this.player.y && !obs.passed) {
                    obs.passed = true;
                    this.score += 5;
                }
            }
        }
        
        // æ£€æŸ¥å¥–åŠ±ç¢°æ’
        for (let i = this.bonuses.length - 1; i >= 0; i--) {
            const bonus = this.bonuses[i];
            const bonusX = this.laneX(bonus.lane);
            const dx = playerX - bonusX;
            const dy = this.player.y - bonus.y;
            
            if (Math.sqrt(dx * dx + dy * dy) < 25) {
                if (bonus.type === 'score') {
                    this.score += 50;
                } else if (bonus.type === 'speedBoost') {
                    this.speed += 2;
                    setTimeout(() => {
                        if (this.speed > 4) this.speed -= 2;
                    }, 3000);
                }
                this.bonuses.splice(i, 1);
            }
        }
    }

    cleanupObjects() {
        // æ¸…ç†éšœç¢ç‰©
        this.obstacles = this.obstacles.filter(obs => obs.y < this.canvas.height + 100);
        
        // æ¸…ç†å¥–åŠ±
        this.bonuses = this.bonuses.filter(bonus => bonus.y < this.canvas.height + 50);
    }

    gameOver() {
        this.state = 'over';
        this.best = Math.max(this.best, Math.floor(this.score));
        localStorage.setItem('bestScore', this.best);
        this.renderUI();
    }

    renderUI() {
        this.ui.innerHTML = '';
        
        if (this.state === 'start') {
            this.ui.innerHTML = `
                <div class="ui-panel" style="position: absolute; top: 50%; transform: translateY(-50%); width: 100%;">
                    <h1>ğŸ€ å®¶åº­ç¯®çƒè·‘é…· ğŸ€</h1>
                    <p>æ»‘åŠ¨åˆ‡æ¢è½¨é“ Â· ç‚¹å‡»è·³è·ƒ Â· é¿å¼€éšœç¢ç‰©</p>
                    <button onclick="game.showCharacterSelect()">å¼€å§‹æ¸¸æˆ</button>
                    <p>æœ€é«˜åˆ†ï¼š${this.best}</p>
                    <p style="color: #aaa; font-size: 14px;">ä¸åŒè§’è‰²æœ‰ä¸åŒç‰¹æ®Šèƒ½åŠ›ï¼</p>
                </div>
                <div class="controls-hint">
                    æç¤ºï¼šå·¦å³æ»‘åŠ¨æ¢é“ï¼Œç‚¹å‡»å±å¹•è·³è·ƒ
                </div>
            `;
        } else if (this.state === 'character') {
            this.ui.innerHTML = `
                <div class="character-select ui-panel">
                    <h2>é€‰æ‹©ä½ çš„è§’è‰²</h2>
                    <div class="char-grid">
                        <div class="char-option ${this.selectedCharacter === 'çˆ¸çˆ¸' ? 'selected' : ''}" 
                             onclick="game.selectCharacter('çˆ¸çˆ¸')">
                            <div class="char-avatar" style="background: #FF9800;">ğŸ‘¨</div>
                            <div class="char-name">çˆ¸çˆ¸</div>
                            <div class="char-ability">ç‰¹æ®Šï¼šäºŒæ®µè·³</div>
                        </div>
                        <!-- å…¶ä»–è§’è‰²ç±»ä¼¼ -->
                    </div>
                    <button onclick="game.startGame()">å¼€å§‹è·‘é…·</button>
                </div>
            `;
        } else if (this.state === 'play') {
            this.ui.innerHTML = `
                <div class="score-display">å¾—åˆ†: ${Math.floor(this.score)}</div>
                <div class="controls-hint">
                    å¾—åˆ†: ${Math.floor(this.score)} | é€Ÿåº¦: ${this.speed.toFixed(1)} | éš¾åº¦: ${this.difficultyLevel}
                </div>
            `;
        } else if (this.state === 'over') {
            let comment = '';
            const finalScore = Math.floor(this.score);
            if (finalScore < 50) comment = 'ç»§ç»­ç»ƒä¹ ï¼';
            else if (finalScore < 100) comment = 'ä¸é”™å“¦ï¼';
            else if (finalScore < 200) comment = 'å¤ªæ£’äº†ï¼';
            else comment = 'ä½ æ˜¯ç¯®çƒå¤§å¸ˆï¼';
            
            this.ui.innerHTML = `
                <div class="game-over ui-panel">
                    <h2>æ¸¸æˆç»“æŸ</h2>
                    <p>å¾—åˆ†ï¼š${finalScore}</p>
                    <p>${comment}</p>
                    <p>æœ€é«˜åˆ†ï¼š${this.best}</p>
                    <button onclick="game.showCharacterSelect()">é€‰æ‹©è§’è‰²é‡ç©</button>
                    <button onclick="game.startGame()">å†æ¥ä¸€å±€</button>
                </div>
            `;
        }
        
        // ç»‘å®šäº‹ä»¶
        this.bindUIEvents();
    }

    bindUIEvents() {
        // ä¸ºæ‰€æœ‰æŒ‰é’®æ·»åŠ äº‹ä»¶ä»£ç†
        setTimeout(() => {
            const buttons = this.ui.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            });
        }, 0);
    }

    showCharacterSelect() {
        this.state = 'character';
        this.renderUI();
    }

    selectCharacter(char) {
        this.selectedCharacter = char;
    }

    startGame() {
        this.state = 'play';
        this.score = 0;
        this.speed = 4;
        this.frame = 0;
        this.obstacles = [];
        this.bonuses = [];
        this.player.lane = 0;
        this.player.jumping = false;
        this.player.doubleJumpUsed = false;
        this.player.specialCooldown = 0;
        this.difficultyLevel = 1;
        this.obstacleSpawnRate = 0.18;
        this.initBuildings();
        this.renderUI();
    }
}

// å¯åŠ¨æ¸¸æˆ
let game;

window.addEventListener('load', () => {
    // è®¾ç½®è§†å£
    document.documentElement.style.height = '100%';
    document.body.style.height = '100%';
    
    // ç¦ç”¨åŒå‡»ç¼©æ”¾
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
    
    // å¯åŠ¨æ¸¸æˆ
    game = new Game();
    
    // é˜»æ­¢å³é”®èœå•
    document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });
});

// å…¨å±åŠŸèƒ½
function toggleFullscreen() {
    const doc = window.document;
    const docEl = doc.documentElement;
    
    const requestFullScreen = docEl.requestFullscreen || 
                             docEl.mozRequestFullScreen || 
                             docEl.webkitRequestFullScreen || 
                             docEl.msRequestFullscreen;
    
    const exitFullScreen = doc.exitFullscreen || 
                          doc.mozCancelFullScreen || 
                          doc.webkitExitFullscreen || 
                          doc.msExitFullscreen;
    
    if (!doc.fullscreenElement && !doc.mozFullScreenElement && 
        !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
        requestFullScreen.call(docEl).catch(err => {
            console.log(`å…¨å±è¯·æ±‚å¤±è´¥: ${err.message}`);
        });
    } else {
        exitFullScreen.call(doc);
    }
}

// æ·»åŠ å…¨å±æŒ‰é’®åˆ° UI
document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('container');
    const fullscreenBtn = document.createElement('div');
    fullscreenBtn.className = 'fullscreen-btn';
    fullscreenBtn.innerHTML = 'â›¶';
    fullscreenBtn.addEventListener('click', toggleFullscreen);
    container.appendChild(fullscreenBtn);
});

// å¤„ç†æ–¹å‘é”å®š
function lockOrientation() {
    if (screen.orientation && screen.orientation.lock) {
        screen.orientation.lock('landscape').catch(() => {
            // é”å®šå¤±è´¥ï¼Œç»§ç»­æ¸¸æˆ
        });
    }
}

// é¡µé¢å¯è§æ€§å˜åŒ–
document.addEventListener('visibilitychange', () => {
    if (game && game.state === 'play' && document.hidden) {
        game.state = 'paused';
        game.renderUI();
    }
});

// å¤„ç†è¿”å›é”®
window.addEventListener('popstate', (e) => {
    if (game && game.state === 'play') {
        e.preventDefault();
        game.state = 'paused';
        game.renderUI();
    }
});
</script>
</body>
</html>
